Hash работает правильно
Генеруруется неправильный мастер ключ.
первые 32 байта расшифрованной базы данных не совпадают с полем Stream Start Bytes заголовка.


Как узнать колько сущностей надо для расшифровки конккреного файла?


https://gist.github.com/moxus/7789b93119df777465ea
https://keepass.info/help/kb/kdbx_4.html

search
console tool to decrypt .kdbx file
decrypt .kdbx file in C

AES
https://github.com/alambley/aes256/blob/master/aes256.h?
https://github.com/chettrick/aes256?
https://github.com/kokke/tiny-AES-c/blob/master/README.md -

structure of *.kdbx file
https://news.ycombinator.com/item?id=16484216
https://gist.github.com/lgg/e6ccc6e212d18dd2ecd8a8c116fb1e45
https://github.com/devio/mod0keecrack/blob/master/mod0keecrack.c
https://github.com/liheyuan/keepasscxx
https://habr.com/ru/post/346820/
https://gist.github.com/lgg/e6ccc6e212d18dd2ecd8a8c116fb1e45#:~:text=kdb%20or%20.,XML%20and%20encrypted%20(normally).
https://gist.github.com/msmuenchen/9318327


decrypt C kdbx file
https://keepass.info/help/kb/kdbx_4.html
https://gist.github.com/msmuenchen/9318327

algorithm SHA256 in C
https://github.com/jb55/sha256.c

AES-256-CBC


how to decrypt  *.kdbx

https://github.com/devio/mod0keecrack
SHA256 
keepass
https://gist.github.com/msmuenchen/9318327

https://weekly-geekly.github.io/articles/346820/index.html
https://habr.com/ru/post/346820/
https://learnc.info/c/binary_files.html
https://bitbucket.org/thirdpin_team/pastilda/src/master/



в eclipse есть горячие клавиши чтобы вдигать выделеные подстроки вправо\влево в пределах строки сквозь уже написанный текст?





KDBX files, the keepass database files, are layout as follows:

1) Bytes 0-3: Primary identifier, common across all kdbx versions: 
  private static $sigByte1=[0x03,0xD9,0xA2,0x9A];

2) Bytes 4-7: Secondary identifier. Byte 4 can be used to identify the file version (0x67 is latest, 0x66 is the KeePass 2 pre-release format and 0x55 is KeePass 1)
	private static $sigByte2=[0x67,0xFB,0x4B,0xB5];

3) Bytes 8-9: LE WORD, file version (minor)

4) Bytes 10-11: LE WORD, file version (major)

5) Dynamic header. Each header entry is [BYTE bId, LE WORD wSize, BYTE[wSize] bData].
5.1) bId=0: END entry, no more header entries after this
5.2) bId=1: COMMENT entry, unknown
5.3) bId=2: CIPHERID, 
bData="31c1f2e6bf714350be5805216afc5aff" => outer encryption AES256, currently no others supported
 
5.4) bId=3: COMPRESSION FLAGS, LE DWORD. 0=payload not compressed, 1=payload compressed with GZip
5.5) bId=4: MASTER_SEED, 32 BYTEs string. See further down for usage/purpose. Length MUST be checked (32 in my file).
5.6) bId=5: TRANSFORM_SEED, variable length BYTE string. See further down for usage/purpose.
5.7) bId=6: TRANSFORM_ROUNDS, LE QWORD. See further down for usage/purpose.
5.8) bId=7: ENCRYPTION_IV, variable length BYTE string. See further down for usage/purpose.
5.9) bId=8: PROTECTED_STREAM_KEY, variable length BYTE string. See further down for usage/purpose.
5.10) bId=9: STREAMS_TART_BYTES, variable length BYTE string. See further down for usage/purpose.
5.11) bId=10: INNER_RANDOM_STREAM_ID, LE DWORD. Inner stream encryption type, 0=>none, 1=>Arc4Variant, 2=>Salsa20

6) Payload area (from end of header until file end).
6.1) BYTE[len(STREAM_START_BYTES)] BYTE string. When payload area is successfully decrypted, this area MUST equal STREAM START BYTES. Normally the length is 32 bytes.
6.2) There are at least 2 payload blocks in the file, 
each is laid out [LE DWORD dwBlockId/ BYTE[32] sHash/ LE DWORD dwBlockSize/ BYTE[dwBlockSize] bData].

dwBlockSize=0 and sHash=\0\0\...\0 (32x \0) signal the final block, this is the last data in the file.

To decrypt the payload area (encrypted as a whole), one needs to do the following:
1) gather all the key composites and concatenate their bytes together. 
The obvious one is the password composite, whose bytes are gathered by taking the sha256 hash of the password (32 bytes).

2) Over the concatenated composite key bytes, make a sha256 hash. This is the "composite key".

3) Establish an AES128-ECB context, IV=16x \0, key TRANSFORM_SEED.

4) Copy the "composite key" into a variable called "transformed key". Over this variable, run the pseudocode transformed_key=aes.encrypt(transformed_key) the number of times specified in TRANSFORM_ROUNDS.

5) Finally, set transformed_key=sha256(transformed_key).

6) Obtain the master key by running master_key=sha256(CONCAT(MASTER_SEED,transformed_key)).


7) Depending on CIPHER_ID, set up a decryption context with key master_key and IV ENCRYPTION_IV. For the default AES encryption, use AES128-CBC with PKCS#7-style padding. This will yield raw_payload_area.

8) Using the payload area specs from above, split out the individual payload blocks. 
In a kdbx file there should only be one block with ID 0 be present. 
Checking if the (master)key is correct can be done by comparing the first X bytes of the payload area with the value of STREAM_START_BYTES in the header, 
X is the length of STREAM_START_BYTES.

9) If COMPRESSIONFLAGS = 1, run bData through gzdecode() to obtain the plain Keepass XML file; if COMPRESSIONFLAGS is 0, it is already in bData.

10) Depending on INNER_RANDOM_STREAM_ID, set up the inner stream context. 0 will mean all passwords in the XML will be in plain text, 1 that they are encrypted with Arc4Variant (not detailed here) and 2 that they will be encrypted with Salsa20.

11) Set up a Salsa20 context using key PROTECTED STREAM KEY and fixed IV [0xE8,0x30,0x09,0x4B,0x97,0x20,0x5D,0x2A].

12) Sequentially(!) look in the XML for "Value" nodes with the "Protected" attribute set to "True" (a suitable xpath might be "//Value[@Protected='True']").

13) Obtain their innerText and run it through base64_decode to obtain the encrypted password/data. Then, run it through salsa20 to obtain the cleartext data.

14) Optionally, check the header for integrity by taking sha256() hash of the whole header (up to, but excluding, the payload start bytes) and compare it with the base64_encode()d hash in the XML node <HeaderHash>(...)</HeaderHash>.

= Notes =
The inner stream cipher is supposed to deliver the same pseudo-random byte sequence using key+fixed IV as seed. Because of this, strict care must be taken to not mess up the ordering of decryption.

